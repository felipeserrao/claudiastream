import openai
import re
import time

from src.utils import is_debug

import pandas as pd


def get_completion_from_messages(messages, model="gpt-4", temperature=0):
    max_retries = 3
    retry_delay = 1  # initial delay in seconds
    retry_count = 0

    while retry_count < max_retries:
        try:
            response = openai.ChatCompletion.create(
                model=model,
                messages=messages,
                temperature=temperature,
            )
            return response.choices[0].message["content"]
        except Exception as e:
            print(f"An error occurred: {str(e)}")
            print(f"Retrying in {retry_delay} seconds...")
            time.sleep(retry_delay)
            retry_delay *= 2  # increase the delay exponentially
            retry_count += 1

    # If all retries fail, return None or raise an exception
    return ''


def get_completion_summary(prompt: str, model: str="gpt-3.5-turbo"):
    """
    Given a prompt message and a language model, use OpenAI's Chat API to generate a 
    summary response message.
    
    Args:
    prompt (str): A prompt message to be used as the input for the language model.
    model (str): The name of the language model to be used. Default is "gpt-3.5-turbo".
    
    Returns:
    str: The response summary generated by the language model.
    """
    messages = [{"role": "user", "content": prompt}]

    return get_completion_from_messages(messages, model, 0)

def format_conversation_history(context: list) -> str:
  """
  Given a list of dictionaries containing a conversation history, format the conversation into a string.
  
  Returns:
  str: A formatted string containing the conversation history, with each message delimited by a new line.
  """
  conversation_list = context[1:-1]
  conversation_str = ''

  for conversation in conversation_list:
    role = conversation['role']
    if role == 'USER':
        role = 'user'
    else:
        role = 'assistant'
    content = conversation['content']
    conversation_str += f'{role}: {content} \n'
  
  return conversation_str

def extract_confidence(text):
    try:
        match = re.search(r'\[(\d+)\]$', text)
        number = match.group(1)

        if not is_debug():
            text = re.sub(r'\s*\[\d+\]$', '', text)

        confidence = int(number)

        return text, confidence
    except:
        return text, 101

def add_sections_to_prompt(prompt: str, sources:list) -> str:
    sections = ""
    for source in sources:
        sections += f" {source.page_content}\n\n###\n\n"
    
    pattern = re.compile(r"(={22})([\s\S]*?)(={22})")  # Regular expression pattern

    final_prompt = re.sub(pattern, rf"\1 {sections} \3", prompt) 

    return final_prompt

def collect_messages(prompt: str, index, context: list):
    sources = []

    if prompt:
        sources = search_docs(index, prompt)
        system_msg = context[0]["content"]
        context[0]["content"] = add_sections_to_prompt(system_msg, sources)

    context.append({ "role": "user", "content": prompt })
    response = get_completion_from_messages(context) 
    context.append({ "role": "assistant", "content": response })
 
    return response, sources